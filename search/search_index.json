{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyGenericSpreadSheet API Documentation","text":""},{"location":"#spreadsheet.googlesheet","title":"<code>googlesheet</code>","text":"<p>Created on 2022-04-18</p> <p>@author: wf</p>"},{"location":"#spreadsheet.googlesheet.GoogleSheet","title":"<code>GoogleSheet</code>","text":"<p>               Bases: <code>object</code></p> <p>GoogleSheet Handling</p> Source code in <code>spreadsheet/googlesheet.py</code> <pre><code>class GoogleSheet(object):\n    \"\"\"\n    GoogleSheet Handling\n    \"\"\"\n\n    def __init__(self, url: str, readonly: bool = True, max_retries:int=5, max_wait:float=60.0):\n        \"\"\"\n        Initializes an instance of GoogleSheet.\n\n        Args:\n            url (str): URL to the Google Sheet.\n            readonly (bool): If True, uses read-only scopes, otherwise uses full access scopes.\n        \"\"\"\n        self.url = url\n        self.sheet_dict = {}\n        self.scopes = ['https://www.googleapis.com/auth/spreadsheets.readonly'] \\\n                      if readonly else \\\n                      ['https://www.googleapis.com/auth/spreadsheets']\n        self.sheet_dict = {}\n        self.max_retries=max_retries\n        self.max_wait=max_wait\n        self.credentials = self.get_credentials()\n\n    def safe_api_call(self, func, *args, **kwargs):\n        \"\"\"\n        Safe wrapper for API calls with exponential backoff.\n\n        Args:\n            func: The API function to call.\n            *args: Arguments for the API function.\n            **kwargs: Keyword arguments for the API function.\n\n        Returns:\n            The result of the API function call.\n        \"\"\"\n        base_sleep = 1  # Initial sleep time in seconds\n        total_sleep = 0  # Total time slept\n\n        for attempt in range(self.max_retries):\n            try:\n                return func(*args, **kwargs)\n            except gspread.exceptions.APIError as e:\n                if e.response.status_code != 429:\n                    raise  # Reraise if not a quota limit error\n\n                # Calculate sleep time with exponential backoff\n                sleep_time = min(base_sleep * (2 ** attempt) + random.random(), self.max_wait - total_sleep)\n                if total_sleep + sleep_time &gt; self.max_wait:\n                    raise Exception(f\"Exceeded maximum wait time of {self.max_wait} seconds for Google API calls.\") from e\n\n                print(f\"Quota exceeded, retrying in {sleep_time:.2f} seconds.\")\n                time.sleep(sleep_time)\n                total_sleep += sleep_time\n        raise Exception(\"Maximum retries reached without success.\")\n\n    def get_credentials(self):\n        \"\"\"\n        Check for Google API credentials in the home directory or\n        the GOOGLE_API_KEY environment variable\n        \"\"\"\n        google_api_key_json=os.getenv(\"GOOGLE_API_KEY\")\n        credentials=None\n        if google_api_key_json:\n            creds_dict=json.loads(google_api_key_json)\n            credentials=Credentials.from_service_account_info(creds_dict, scopes=self.scopes)\n        else:\n            cred_path = os.path.join(os.path.expanduser(\"~\"), \".ose\", \"google-api-key.json\")\n            if os.path.exists(cred_path):\n                credentials = Credentials.from_service_account_file(cred_path, scopes=self.scopes)\n        return credentials\n\n\n    def open(self, sheet_names: list = None) -&gt; dict:\n        \"\"\"\n        Opens the Google Sheet and loads the data from specified sheet names into a dictionary.\n\n        Args:\n            sheet_names: Optional list of sheet names to open. Opens all sheets if None.\n\n        Returns:\n            A dictionary with sheet names as keys and lists of dictionaries (rows) as values.\n        \"\"\"\n        credentials = self.get_credentials()\n        if not credentials:\n            raise Exception(\"Credentials not found.\")\n\n        self.gc = gspread.authorize(credentials)\n        self.sh = self.safe_api_call(self.gc.open_by_url, self.url)\n        # Retrieve all sheet names if none are provided\n        sheet_names = sheet_names or [sheet.title for sheet in self.sh.worksheets()]\n\n        for sheet_name in sheet_names:\n            worksheet = self.sh.worksheet(sheet_name)\n            records = self.safe_api_call(worksheet.get_all_records)\n            self.sheet_dict[sheet_name] = records\n\n        return self.sheet_dict\n\n    def asListOfDicts(self, sheet_name: str)-&gt;List:\n        \"\"\"\n        Converts a sheet to a list of dictionaries.\n\n        Args:\n            sheet_name (str): The name of the sheet to convert.\n\n        Returns:\n            A list of dictionaries, each representing a row in the sheet.\n        \"\"\"\n        if not sheet_name in self.sheet_dict:\n            self.open[sheet_name]\n        lod = self.sheet_dict.get(sheet_name)\n        return lod\n\n    def fixRows(self, lod: list):\n        \"\"\"\n        fix Rows by filtering unnamed columns and trimming\n        column names\n        \"\"\"\n        for row in lod:\n            for key in list(row.keys()):\n                if key.startswith(\"Unnamed\"):\n                    del row[key]\n                trimmedKey = key.strip()\n                if trimmedKey != key:\n                    value = row[key]\n                    row[trimmedKey] = value\n                    del row[key]\n\n    @classmethod\n    def toWikibaseQuery(\n        cls, url: str, sheetName: str = \"WikidataMapping\", debug: bool = False\n    ) -&gt; Dict[str, \"WikibaseQuery\"]:\n        \"\"\"\n        create a dict of wikibaseQueries from the given google sheets row descriptions\n\n        Args:\n            url(str): the url of the sheet\n            sheetName(str): the name of the sheet with the description\n            debug(bool): if True switch on debugging\n        \"\"\"\n        gs = GoogleSheet(url)\n        gs.open([sheetName])\n        entityMapRows = gs.asListOfDicts(sheetName)\n        queries=WikibaseQuery.ofMapRows(entityMapRows, debug=debug)\n        return queries\n\n    @classmethod\n    def toSparql(\n        cls,\n        url: str,\n        sheetName: str,\n        entityName: str,\n        pkColumn: str,\n        mappingSheetName: str = \"WikidataMapping\",\n        lang: str = \"en\",\n        debug: bool = False,\n    ) -&gt; (\"WikibaseQuery\", str):\n        \"\"\"\n        get a sparql query for the given google sheet\n\n        Args:\n            url (str): the url of the sheet\n            sheetName (str): the name of the sheet with the description\n            entityName (str): the name of the entity as defined in the Wikidata mapping\n            pkColumn (str): the column to use as a \"primary key\"\n            mappingSheetName (str): the name of the sheet with the Wikidata mappings\n            lang (str): the language to use (if any)\n            debug (bool): if True switch on debugging\n\n        Returns:\n            WikibaseQuery\n        \"\"\"\n        queries = cls.toWikibaseQuery(url, mappingSheetName, debug)\n        gs = GoogleSheet(url)\n        gs.open([sheetName])\n        lod = gs.asListOfDicts(sheetName)\n        lodByPk, _dup = LOD.getLookup(lod, pkColumn)\n        query = queries[entityName]\n        propRow = query.propertiesByColumn[pkColumn]\n        pk = propRow[\"PropertyName\"]\n        pkVarname = propRow[\"PropVarname\"]\n        pkType = propRow[\"Type\"]\n        valuesClause = query.getValuesClause(\n            lodByPk.keys(), propVarname=pkVarname, propType=pkType, lang=lang\n        )\n\n        sparql = query.asSparql(\n            filterClause=valuesClause, orderClause=f\"ORDER BY ?{pkVarname}\", pk=pk\n        )\n        return query, sparql\n</code></pre>"},{"location":"#spreadsheet.googlesheet.GoogleSheet.__init__","title":"<code>__init__(url, readonly=True, max_retries=5, max_wait=60.0)</code>","text":"<p>Initializes an instance of GoogleSheet.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Google Sheet.</p> required <code>readonly</code> <code>bool</code> <p>If True, uses read-only scopes, otherwise uses full access scopes.</p> <code>True</code> Source code in <code>spreadsheet/googlesheet.py</code> <pre><code>def __init__(self, url: str, readonly: bool = True, max_retries:int=5, max_wait:float=60.0):\n    \"\"\"\n    Initializes an instance of GoogleSheet.\n\n    Args:\n        url (str): URL to the Google Sheet.\n        readonly (bool): If True, uses read-only scopes, otherwise uses full access scopes.\n    \"\"\"\n    self.url = url\n    self.sheet_dict = {}\n    self.scopes = ['https://www.googleapis.com/auth/spreadsheets.readonly'] \\\n                  if readonly else \\\n                  ['https://www.googleapis.com/auth/spreadsheets']\n    self.sheet_dict = {}\n    self.max_retries=max_retries\n    self.max_wait=max_wait\n    self.credentials = self.get_credentials()\n</code></pre>"},{"location":"#spreadsheet.googlesheet.GoogleSheet.asListOfDicts","title":"<code>asListOfDicts(sheet_name)</code>","text":"<p>Converts a sheet to a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>sheet_name</code> <code>str</code> <p>The name of the sheet to convert.</p> required <p>Returns:</p> Type Description <code>List</code> <p>A list of dictionaries, each representing a row in the sheet.</p> Source code in <code>spreadsheet/googlesheet.py</code> <pre><code>def asListOfDicts(self, sheet_name: str)-&gt;List:\n    \"\"\"\n    Converts a sheet to a list of dictionaries.\n\n    Args:\n        sheet_name (str): The name of the sheet to convert.\n\n    Returns:\n        A list of dictionaries, each representing a row in the sheet.\n    \"\"\"\n    if not sheet_name in self.sheet_dict:\n        self.open[sheet_name]\n    lod = self.sheet_dict.get(sheet_name)\n    return lod\n</code></pre>"},{"location":"#spreadsheet.googlesheet.GoogleSheet.fixRows","title":"<code>fixRows(lod)</code>","text":"<p>fix Rows by filtering unnamed columns and trimming column names</p> Source code in <code>spreadsheet/googlesheet.py</code> <pre><code>def fixRows(self, lod: list):\n    \"\"\"\n    fix Rows by filtering unnamed columns and trimming\n    column names\n    \"\"\"\n    for row in lod:\n        for key in list(row.keys()):\n            if key.startswith(\"Unnamed\"):\n                del row[key]\n            trimmedKey = key.strip()\n            if trimmedKey != key:\n                value = row[key]\n                row[trimmedKey] = value\n                del row[key]\n</code></pre>"},{"location":"#spreadsheet.googlesheet.GoogleSheet.get_credentials","title":"<code>get_credentials()</code>","text":"<p>Check for Google API credentials in the home directory or the GOOGLE_API_KEY environment variable</p> Source code in <code>spreadsheet/googlesheet.py</code> <pre><code>def get_credentials(self):\n    \"\"\"\n    Check for Google API credentials in the home directory or\n    the GOOGLE_API_KEY environment variable\n    \"\"\"\n    google_api_key_json=os.getenv(\"GOOGLE_API_KEY\")\n    credentials=None\n    if google_api_key_json:\n        creds_dict=json.loads(google_api_key_json)\n        credentials=Credentials.from_service_account_info(creds_dict, scopes=self.scopes)\n    else:\n        cred_path = os.path.join(os.path.expanduser(\"~\"), \".ose\", \"google-api-key.json\")\n        if os.path.exists(cred_path):\n            credentials = Credentials.from_service_account_file(cred_path, scopes=self.scopes)\n    return credentials\n</code></pre>"},{"location":"#spreadsheet.googlesheet.GoogleSheet.open","title":"<code>open(sheet_names=None)</code>","text":"<p>Opens the Google Sheet and loads the data from specified sheet names into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>sheet_names</code> <code>list</code> <p>Optional list of sheet names to open. Opens all sheets if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with sheet names as keys and lists of dictionaries (rows) as values.</p> Source code in <code>spreadsheet/googlesheet.py</code> <pre><code>def open(self, sheet_names: list = None) -&gt; dict:\n    \"\"\"\n    Opens the Google Sheet and loads the data from specified sheet names into a dictionary.\n\n    Args:\n        sheet_names: Optional list of sheet names to open. Opens all sheets if None.\n\n    Returns:\n        A dictionary with sheet names as keys and lists of dictionaries (rows) as values.\n    \"\"\"\n    credentials = self.get_credentials()\n    if not credentials:\n        raise Exception(\"Credentials not found.\")\n\n    self.gc = gspread.authorize(credentials)\n    self.sh = self.safe_api_call(self.gc.open_by_url, self.url)\n    # Retrieve all sheet names if none are provided\n    sheet_names = sheet_names or [sheet.title for sheet in self.sh.worksheets()]\n\n    for sheet_name in sheet_names:\n        worksheet = self.sh.worksheet(sheet_name)\n        records = self.safe_api_call(worksheet.get_all_records)\n        self.sheet_dict[sheet_name] = records\n\n    return self.sheet_dict\n</code></pre>"},{"location":"#spreadsheet.googlesheet.GoogleSheet.safe_api_call","title":"<code>safe_api_call(func, *args, **kwargs)</code>","text":"<p>Safe wrapper for API calls with exponential backoff.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The API function to call.</p> required <code>*args</code> <p>Arguments for the API function.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments for the API function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The result of the API function call.</p> Source code in <code>spreadsheet/googlesheet.py</code> <pre><code>def safe_api_call(self, func, *args, **kwargs):\n    \"\"\"\n    Safe wrapper for API calls with exponential backoff.\n\n    Args:\n        func: The API function to call.\n        *args: Arguments for the API function.\n        **kwargs: Keyword arguments for the API function.\n\n    Returns:\n        The result of the API function call.\n    \"\"\"\n    base_sleep = 1  # Initial sleep time in seconds\n    total_sleep = 0  # Total time slept\n\n    for attempt in range(self.max_retries):\n        try:\n            return func(*args, **kwargs)\n        except gspread.exceptions.APIError as e:\n            if e.response.status_code != 429:\n                raise  # Reraise if not a quota limit error\n\n            # Calculate sleep time with exponential backoff\n            sleep_time = min(base_sleep * (2 ** attempt) + random.random(), self.max_wait - total_sleep)\n            if total_sleep + sleep_time &gt; self.max_wait:\n                raise Exception(f\"Exceeded maximum wait time of {self.max_wait} seconds for Google API calls.\") from e\n\n            print(f\"Quota exceeded, retrying in {sleep_time:.2f} seconds.\")\n            time.sleep(sleep_time)\n            total_sleep += sleep_time\n    raise Exception(\"Maximum retries reached without success.\")\n</code></pre>"},{"location":"#spreadsheet.googlesheet.GoogleSheet.toSparql","title":"<code>toSparql(url, sheetName, entityName, pkColumn, mappingSheetName='WikidataMapping', lang='en', debug=False)</code>  <code>classmethod</code>","text":"<p>get a sparql query for the given google sheet</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>the url of the sheet</p> required <code>sheetName</code> <code>str</code> <p>the name of the sheet with the description</p> required <code>entityName</code> <code>str</code> <p>the name of the entity as defined in the Wikidata mapping</p> required <code>pkColumn</code> <code>str</code> <p>the column to use as a \"primary key\"</p> required <code>mappingSheetName</code> <code>str</code> <p>the name of the sheet with the Wikidata mappings</p> <code>'WikidataMapping'</code> <code>lang</code> <code>str</code> <p>the language to use (if any)</p> <code>'en'</code> <code>debug</code> <code>bool</code> <p>if True switch on debugging</p> <code>False</code> <p>Returns:</p> Type Description <code>(WikibaseQuery, str)</code> <p>WikibaseQuery</p> Source code in <code>spreadsheet/googlesheet.py</code> <pre><code>@classmethod\ndef toSparql(\n    cls,\n    url: str,\n    sheetName: str,\n    entityName: str,\n    pkColumn: str,\n    mappingSheetName: str = \"WikidataMapping\",\n    lang: str = \"en\",\n    debug: bool = False,\n) -&gt; (\"WikibaseQuery\", str):\n    \"\"\"\n    get a sparql query for the given google sheet\n\n    Args:\n        url (str): the url of the sheet\n        sheetName (str): the name of the sheet with the description\n        entityName (str): the name of the entity as defined in the Wikidata mapping\n        pkColumn (str): the column to use as a \"primary key\"\n        mappingSheetName (str): the name of the sheet with the Wikidata mappings\n        lang (str): the language to use (if any)\n        debug (bool): if True switch on debugging\n\n    Returns:\n        WikibaseQuery\n    \"\"\"\n    queries = cls.toWikibaseQuery(url, mappingSheetName, debug)\n    gs = GoogleSheet(url)\n    gs.open([sheetName])\n    lod = gs.asListOfDicts(sheetName)\n    lodByPk, _dup = LOD.getLookup(lod, pkColumn)\n    query = queries[entityName]\n    propRow = query.propertiesByColumn[pkColumn]\n    pk = propRow[\"PropertyName\"]\n    pkVarname = propRow[\"PropVarname\"]\n    pkType = propRow[\"Type\"]\n    valuesClause = query.getValuesClause(\n        lodByPk.keys(), propVarname=pkVarname, propType=pkType, lang=lang\n    )\n\n    sparql = query.asSparql(\n        filterClause=valuesClause, orderClause=f\"ORDER BY ?{pkVarname}\", pk=pk\n    )\n    return query, sparql\n</code></pre>"},{"location":"#spreadsheet.googlesheet.GoogleSheet.toWikibaseQuery","title":"<code>toWikibaseQuery(url, sheetName='WikidataMapping', debug=False)</code>  <code>classmethod</code>","text":"<p>create a dict of wikibaseQueries from the given google sheets row descriptions</p> <p>Parameters:</p> Name Type Description Default <code>url(str)</code> <p>the url of the sheet</p> required <code>sheetName(str)</code> <p>the name of the sheet with the description</p> required <code>debug(bool)</code> <p>if True switch on debugging</p> required Source code in <code>spreadsheet/googlesheet.py</code> <pre><code>@classmethod\ndef toWikibaseQuery(\n    cls, url: str, sheetName: str = \"WikidataMapping\", debug: bool = False\n) -&gt; Dict[str, \"WikibaseQuery\"]:\n    \"\"\"\n    create a dict of wikibaseQueries from the given google sheets row descriptions\n\n    Args:\n        url(str): the url of the sheet\n        sheetName(str): the name of the sheet with the description\n        debug(bool): if True switch on debugging\n    \"\"\"\n    gs = GoogleSheet(url)\n    gs.open([sheetName])\n    entityMapRows = gs.asListOfDicts(sheetName)\n    queries=WikibaseQuery.ofMapRows(entityMapRows, debug=debug)\n    return queries\n</code></pre>"},{"location":"#spreadsheet.spreadsheet","title":"<code>spreadsheet</code>","text":""},{"location":"#spreadsheet.spreadsheet.CSVSpreadSheet","title":"<code>CSVSpreadSheet</code>","text":"<p>               Bases: <code>SpreadSheet</code></p> <p>CSV Spreadsheet packaging as ZIP file of CSV files</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>class CSVSpreadSheet(SpreadSheet):\n    \"\"\"\n    CSV Spreadsheet packaging as ZIP file of CSV files\n    \"\"\"\n\n    FILE_TYPE = \".zip\"\n    TABLE_TYPE = \".csv\"\n    MIME_TYPE = \"application/zip\"\n\n    def __init__(self, name: str):\n        super().__init__(name=name, spreadSheetType=SpreadSheetType.CSV)\n\n    def toBytesIO(self) -&gt; BytesIO:\n        \"\"\"\n        Converts the document into an BytesIO stream\n\n        Returns:\n            BytesIO Stream of the document\n        \"\"\"\n        buffer = BytesIO()\n        buffer.name = self.filename\n        with ZipFile(buffer, mode=\"w\") as documentZip:\n            for tableName, table in self.tables.items():\n                csv = CSV.toCSV(table)\n                documentZip.writestr(tableName + self.TABLE_TYPE, csv)\n        buffer.seek(0)\n        return buffer\n\n    def _loadFromBuffer(self, file):\n        \"\"\"\n        load the document from the given .zip file\n        Args:\n            file: absolut file path to the file that should be loaded\n        Returns:\n\n        \"\"\"\n        fileName = file.name\n        tables = {}\n        if fileName.endswith(self.FILE_TYPE):\n            with ZipFile(file, mode=\"r\") as documentZip:\n                archivedFiles = documentZip.namelist()\n                for archivedFile in archivedFiles:\n                    with documentZip.open(archivedFile) as csvFile:\n                        lod = CSV.fromCSV(csvFile.read().decode())\n                        tableName = archivedFile[: -len(self.TABLE_TYPE)]\n                        tables[tableName] = lod\n        elif fileName.endswith(self.TABLE_TYPE):\n            # single csv file load as sheet with one table\n            lod = CSV.fromCSV(file.read().decode())\n            tableName = fileName[: -len(self.TABLE_TYPE)]\n            tables[tableName] = lod\n        return tables\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.CSVSpreadSheet.toBytesIO","title":"<code>toBytesIO()</code>","text":"<p>Converts the document into an BytesIO stream</p> <p>Returns:</p> Type Description <code>BytesIO</code> <p>BytesIO Stream of the document</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>def toBytesIO(self) -&gt; BytesIO:\n    \"\"\"\n    Converts the document into an BytesIO stream\n\n    Returns:\n        BytesIO Stream of the document\n    \"\"\"\n    buffer = BytesIO()\n    buffer.name = self.filename\n    with ZipFile(buffer, mode=\"w\") as documentZip:\n        for tableName, table in self.tables.items():\n            csv = CSV.toCSV(table)\n            documentZip.writestr(tableName + self.TABLE_TYPE, csv)\n    buffer.seek(0)\n    return buffer\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.ExcelDocument","title":"<code>ExcelDocument</code>","text":"<p>               Bases: <code>SpreadSheet</code></p> <p>Provides methods to convert LoDs to an excel document and vice versa</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>class ExcelDocument(SpreadSheet):\n    \"\"\"\n    Provides methods to convert LoDs to an excel document and vice versa\n    \"\"\"\n\n    FILE_TYPE = \".xlsx\"\n    MIME_TYPE = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n\n    def __init__(\n        self,\n        name: str,\n        engine: str = None,\n        spreadSheetType: SpreadSheetType = SpreadSheetType.EXCEL,\n    ):\n        \"\"\"\n        Args:\n            name(str): name of the document\n        \"\"\"\n        super().__init__(name=name, spreadSheetType=spreadSheetType)\n        if engine is None:\n            engine = \"xlsxwriter\"\n        self.engine_kwargs = {\"options\": {\"strings_to_numbers\": True}}\n\n        self.engine = engine\n\n    def toBytesIO(self) -&gt; BytesIO:\n        \"\"\"\n        Converts the document into an BytesIO stream\n\n        Returns:\n            BytesIO Stream of the document\n        \"\"\"\n        buffer = BytesIO()\n\n        with pd.ExcelWriter(\n            buffer,\n            engine=self.engine,\n            engine_kwargs=self.engine_kwargs,\n        ) as writer:\n            for tableName, tableData in self.tables.items():\n                df = pd.DataFrame(tableData)\n                df.to_excel(writer, sheet_name=tableName, index=False)\n        buffer.seek(0)\n        buffer.name = self.filename\n        return buffer\n\n    def _loadFromBuffer(self, buffer):\n        \"\"\"\n        read my table from the given BytesIO buffer\n        \"\"\"\n        sheets = pd.read_excel(buffer, sheet_name=None).keys()\n        tables = {}\n        for sheet in sheets:\n            df = pd.read_excel(buffer, sheet_name=sheet, na_values=None)\n            df = df.where(pd.notnull(df), None)\n            lod = df.to_dict(\"records\")\n            # NaT handling issue due to a bug in pandas https://github.com/pandas-dev/pandas/issues/29024\n            lod = [\n                {\n                    k: v.to_pydatetime()\n                    if isinstance(v, Timestamp)\n                    else None\n                    if isinstance(v, type(NaT))\n                    else v\n                    for k, v in d.items()\n                }\n                for d in lod\n            ]\n            # float nan to None\n            lod = [\n                {\n                    k: v if not (isinstance(v, float) and math.isnan(v)) else None\n                    for k, v in d.items()\n                }\n                for d in lod\n            ]\n            tables[sheet] = lod\n        return tables\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.ExcelDocument.__init__","title":"<code>__init__(name, engine=None, spreadSheetType=SpreadSheetType.EXCEL)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>name of the document</p> required Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    engine: str = None,\n    spreadSheetType: SpreadSheetType = SpreadSheetType.EXCEL,\n):\n    \"\"\"\n    Args:\n        name(str): name of the document\n    \"\"\"\n    super().__init__(name=name, spreadSheetType=spreadSheetType)\n    if engine is None:\n        engine = \"xlsxwriter\"\n    self.engine_kwargs = {\"options\": {\"strings_to_numbers\": True}}\n\n    self.engine = engine\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.ExcelDocument.toBytesIO","title":"<code>toBytesIO()</code>","text":"<p>Converts the document into an BytesIO stream</p> <p>Returns:</p> Type Description <code>BytesIO</code> <p>BytesIO Stream of the document</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>def toBytesIO(self) -&gt; BytesIO:\n    \"\"\"\n    Converts the document into an BytesIO stream\n\n    Returns:\n        BytesIO Stream of the document\n    \"\"\"\n    buffer = BytesIO()\n\n    with pd.ExcelWriter(\n        buffer,\n        engine=self.engine,\n        engine_kwargs=self.engine_kwargs,\n    ) as writer:\n        for tableName, tableData in self.tables.items():\n            df = pd.DataFrame(tableData)\n            df.to_excel(writer, sheet_name=tableName, index=False)\n    buffer.seek(0)\n    buffer.name = self.filename\n    return buffer\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.Format","title":"<code>Format</code>","text":"<p>potential Formats</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>class Format:\n    \"\"\"\n    potential Formats\n    \"\"\"\n\n    formatMap = {\n        \"CSV\": {\n            \"name\": \"CSV\",\n            \"title\": \"Comma separated Values\",\n            \"postfix\": \".csv\",\n            \"mimetype\": \"text/csv\",\n        },\n        \"EXCEL\": {\n            \"name\": \"Excel\",\n            \"title\": \"Microsoft Excel\",\n            \"postfix\": \".xlsx\",\n            \"mimetype\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n        },\n        \"JSON\": {\n            \"name\": \"JSON\",\n            \"title\": \"Javascript Simple Object Notation\",\n            \"postfix\": \".json\",\n            \"mimetype\": \"application/json\",\n        },\n        \"ODS\": {\n            \"name\": \"ODS\",\n            \"title\": \"OpenDocument Spreadsheet\",\n            \"postfix\": \".ods\",\n            \"mimetype\": \"application/vnd.oasis.opendocument.onlinespreadsheet\",\n        },\n    }\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.OdsDocument","title":"<code>OdsDocument</code>","text":"<p>               Bases: <code>ExcelDocument</code></p> <p>OpenDocument Spreadsheet that can store multiple tables. Provides functions to traverse between LoD and ODS document</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>class OdsDocument(ExcelDocument):\n    \"\"\"\n    OpenDocument Spreadsheet that can store multiple tables.\n    Provides functions to traverse between LoD and ODS document\n    \"\"\"\n\n    FILE_TYPE = \".ods\"\n    MIME_TYPE = \"application/vnd.oasis.opendocument.onlinespreadsheet\"\n\n    def __init__(self, name: str):\n        \"\"\"\n        Args:\n            name(str): name of the document\n        \"\"\"\n\n        super().__init__(name=name, spreadSheetType=SpreadSheetType.ODS, engine=\"odf\")\n        self.engine_kwargs = {}\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.OdsDocument.__init__","title":"<code>__init__(name)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>name of the document</p> required Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"\n    Args:\n        name(str): name of the document\n    \"\"\"\n\n    super().__init__(name=name, spreadSheetType=SpreadSheetType.ODS, engine=\"odf\")\n    self.engine_kwargs = {}\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.SpreadSheet","title":"<code>SpreadSheet</code>","text":"<p>i am onlinespreadsheet</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>class SpreadSheet:\n    \"\"\"\n    i am onlinespreadsheet\n    \"\"\"\n\n    FILE_TYPE = NotImplemented\n    MIME_TYPE = NotImplemented\n\n    def __init__(self, name: str, spreadSheetType: SpreadSheetType):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.name = name\n        self.spreadSheetType = spreadSheetType\n        self.tables = {}  # dict of lods\n        pass\n\n    @classmethod\n    def create(cls, spreadSheetType: SpreadSheetType, name: str):\n        \"\"\"\n        create a SpreadSheet of the given types\n\n        Args:\n            spreadSheetType(SpreadSheetType): the type of onlinespreadsheet to create\n            name(str): the name of the onlinespreadsheet\n\n        \"\"\"\n        spreadSheet = None\n        if spreadSheetType == SpreadSheetType.EXCEL:\n            spreadSheet = ExcelDocument(name=name)\n        elif spreadSheetType == SpreadSheetType.ODS:\n            spreadSheet = OdsDocument(name=name)\n        elif spreadSheetType == SpreadSheetType.CSV:\n            spreadSheet = CSVSpreadSheet(name=name)\n        return spreadSheet\n\n    @classmethod\n    def load(cls, document):\n        \"\"\"\n        Tries to load the given document as SpreadSheet\n        Args:\n            document: onlinespreadsheet document to load\n\n        Returns:\n            SpreadSheet\n        \"\"\"\n        documentSpreadSheetType = None\n        documentName = \"\"\n        spreadsheet = None\n        # TODO - use SpreadSheeeType enum instead\n        spreadSheetTypes = [OdsDocument, ExcelDocument, CSVSpreadSheet]\n        # TODO Get rid of Werkzeug dependency ...\n        # if isinstance(document, FileStorage):\n        #    document.stream.seek(0)\n        #    for spreadSheetType in spreadSheetTypes:\n        #        if document.filename.endswith(spreadSheetType.FILE_TYPE):\n        #            documentName=document.filename[:-len(spreadSheetType.FILE_TYPE)]\n        #            documentSpreadSheetType=spreadSheetType\n        #            break\n        if (\n            isinstance(document, io.BytesIO)\n            or isinstance(document, io.StringIO)\n            or isinstance(document, io.TextIOWrapper)\n        ):\n            document.seek(0)\n            for spreadSheetType in spreadSheetTypes:\n                if document.name.endswith(spreadSheetType.FILE_TYPE):\n                    documentName = document.name[: -len(spreadSheetType.FILE_TYPE)]\n                    documentSpreadSheetType = spreadSheetType\n                    break\n        elif isinstance(document, str):\n            try:\n                buffer = None\n                with open(document, \"rb\") as f:\n                    buffer = io.BytesIO(f.read())\n                    buffer.name = document\n                return cls.load(buffer)\n            except Exception as e:\n                print(e)\n                raise e\n        else:\n            print(\"Unable to load SpreadSheet\")\n            return None\n        if documentSpreadSheetType:\n            spreadsheet = documentSpreadSheetType(name=documentName)\n            spreadsheet.loadFromFile(document)\n        return spreadsheet\n\n    def getTable(self, name: str):\n        \"\"\"\n        returns the data corresponding to the given table name\n        Args:\n            name: name of the table\n\n        Returns:\n            LoD\n        \"\"\"\n        if name in self.tables:\n            return self.tables[name]\n\n    def addTable(self, name: str, lod: list, headers: dict = None):\n        \"\"\"\n        add the given data as table to the document\n\n        Args:\n            name(str): name of the table\n            lod: data that should be added to the document as table\n            headers(dict): Mapping from dict key to the new headers. Also functions as restriction. If not defined dict key are used as headers\n        \"\"\"\n        if headers:\n            lod = [\n                {\n                    newHeader: record.get(oldHeader, None)\n                    for oldHeader, newHeader in headers.items()\n                }\n                for record in lod\n            ]\n        self.tables[name] = lod\n\n    def hasTable(self, name: str):\n        \"\"\"\n        Checks if table under given name exists\n\n        Args:\n            name(str): name of the Table\n\n        Retruns:\n            True if table exists otherwise False\n        \"\"\"\n        return name in self.tables\n\n    def saveToFile(self, fileName: str = None, dir_name: str = None):\n        \"\"\"\n        saves SpreadSheet to file\n\n        Args:\n            fileName(str): name of the file if None SpreadSheet name is used\n            dir_name(str): name of directory to store the file\n\n        Returns:\n            Nothing\n        \"\"\"\n        if fileName is None:\n            fileName = self.filename\n        if dir_name is not None:\n            fileName = os.path.join(dir_name, fileName)\n        documentBuffer = self.toBytesIO()\n        with open(fileName, \"wb\") as f:\n            documentBuffer.seek(0)\n            f.write(documentBuffer.read())\n\n    def toBytesIO(self) -&gt; BytesIO:\n        \"\"\"\n        Converts the document into an BytesIO stream\n\n        Returns:\n            BytesIO Stream of the document\n        \"\"\"\n        raise NotImplementedError\n\n    def loadFromFile(self, file, samples: dict = None):\n        \"\"\"\n        Load SpreadSheet from given file or file object\n        \"\"\"\n        tables = self._loadFromFile(file)\n        if tables:\n            for name, table in tables.items():\n                if samples:\n                    if name in samples:\n                        self.fixLodTypes(table, samples[name])\n                self.tables[name] = table\n\n    def _loadFromFile(self, file):\n        \"\"\"\n        load the document from the given .ods file\n        Args:\n            file: absolut file path to the file that should be loaded\n            samples(dict): samples of the sheets. Expected format: sheetName:SamplesForSheet\n        Returns:\n\n        \"\"\"\n        if isinstance(file, str):\n            try:\n                with open(file, mode=\"rb\") as f:\n                    buffer = BytesIO()\n                    buffer.write(f.read())\n                    # work around along the line of\n                    # https://stackoverflow.com/a/42811024/1497139\n                    buffer.name = f.name\n            except Exception as e:\n                print(f\"Tried to open {file} as a File and failed\")\n                raise e\n        else:\n            buffer = file\n        return self._loadFromBuffer(buffer)\n\n    def _loadFromBuffer(self, buffer):\n        \"\"\"\n        Load SpreadSheet from given buffer\n\n        Args:\n            buffer: file like object\n\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def filename(self):\n        return self.name + self.FILE_TYPE\n\n    @staticmethod\n    def fixLodTypes(lod: list, samples: list, typeConversionMap: dict = None):\n        \"\"\"\n        Fixes the types of the values of the given lod by converting it to the type corresponding to the given sampeles\n\n        Args:\n            lod(list): List of dicts to be type fixed\n            samples(list): list of samples specifying the value types\n            typeConversionMap(dict): Map from type to corresponding conversion function. If None default conversions for string values are used.\n        \"\"\"\n        if typeConversionMap is None:\n\n            def toDate(value):\n                if isinstance(value, str):\n                    return dateparser.parse(value).date()\n                elif isinstance(value, datetime):\n                    return value.date()\n                elif isinstance(value, date):\n                    return value\n                else:\n                    print(f\"{value} could not be converted to date\")\n                    return value\n\n            typeConversionMap = {\n                str: lambda value: str(value),\n                int: lambda value: int(value),\n                float: lambda value: float(value),\n                date: lambda value: toDate(value),\n                datetime: lambda value: dateparser.parse(value),\n            }\n        # build sample types map\n        sampleTypes = {}\n        for sample in samples:\n            if isinstance(sample, dict):\n                for key, value in sample.items():\n                    valueType = type(value)\n                    if key not in sampleTypes:\n                        sampleTypes[key] = valueType\n                    elif sampleTypes[key] != valueType:\n                        print(\n                            f\"Sample has inconsistent types for {key} the types {sampleTypes[key]} and {valueType} are defined\"\n                        )\n                    else:\n                        pass\n        # fix types of lod\n        for d in lod:\n            if isinstance(d, dict):\n                for key, value in d.items():\n                    if (\n                        value is not None\n                        and key in sampleTypes\n                        and sampleTypes[key] in typeConversionMap\n                    ):\n                        if type(value) != sampleTypes[key]:\n                            d[key] = typeConversionMap[sampleTypes[key]](value)\n            else:\n                print(\"List of dicts contains a non dict item\")\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.SpreadSheet.__init__","title":"<code>__init__(name, spreadSheetType)</code>","text":"<p>constructor</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>def __init__(self, name: str, spreadSheetType: SpreadSheetType):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.name = name\n    self.spreadSheetType = spreadSheetType\n    self.tables = {}  # dict of lods\n    pass\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.SpreadSheet.addTable","title":"<code>addTable(name, lod, headers=None)</code>","text":"<p>add the given data as table to the document</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>name of the table</p> required <code>lod</code> <code>list</code> <p>data that should be added to the document as table</p> required <code>headers(dict)</code> <p>Mapping from dict key to the new headers. Also functions as restriction. If not defined dict key are used as headers</p> required Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>def addTable(self, name: str, lod: list, headers: dict = None):\n    \"\"\"\n    add the given data as table to the document\n\n    Args:\n        name(str): name of the table\n        lod: data that should be added to the document as table\n        headers(dict): Mapping from dict key to the new headers. Also functions as restriction. If not defined dict key are used as headers\n    \"\"\"\n    if headers:\n        lod = [\n            {\n                newHeader: record.get(oldHeader, None)\n                for oldHeader, newHeader in headers.items()\n            }\n            for record in lod\n        ]\n    self.tables[name] = lod\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.SpreadSheet.create","title":"<code>create(spreadSheetType, name)</code>  <code>classmethod</code>","text":"<p>create a SpreadSheet of the given types</p> <p>Parameters:</p> Name Type Description Default <code>spreadSheetType(SpreadSheetType)</code> <p>the type of onlinespreadsheet to create</p> required <code>name(str)</code> <p>the name of the onlinespreadsheet</p> required Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>@classmethod\ndef create(cls, spreadSheetType: SpreadSheetType, name: str):\n    \"\"\"\n    create a SpreadSheet of the given types\n\n    Args:\n        spreadSheetType(SpreadSheetType): the type of onlinespreadsheet to create\n        name(str): the name of the onlinespreadsheet\n\n    \"\"\"\n    spreadSheet = None\n    if spreadSheetType == SpreadSheetType.EXCEL:\n        spreadSheet = ExcelDocument(name=name)\n    elif spreadSheetType == SpreadSheetType.ODS:\n        spreadSheet = OdsDocument(name=name)\n    elif spreadSheetType == SpreadSheetType.CSV:\n        spreadSheet = CSVSpreadSheet(name=name)\n    return spreadSheet\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.SpreadSheet.fixLodTypes","title":"<code>fixLodTypes(lod, samples, typeConversionMap=None)</code>  <code>staticmethod</code>","text":"<p>Fixes the types of the values of the given lod by converting it to the type corresponding to the given sampeles</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>List of dicts to be type fixed</p> required <code>samples(list)</code> <p>list of samples specifying the value types</p> required <code>typeConversionMap(dict)</code> <p>Map from type to corresponding conversion function. If None default conversions for string values are used.</p> required Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>@staticmethod\ndef fixLodTypes(lod: list, samples: list, typeConversionMap: dict = None):\n    \"\"\"\n    Fixes the types of the values of the given lod by converting it to the type corresponding to the given sampeles\n\n    Args:\n        lod(list): List of dicts to be type fixed\n        samples(list): list of samples specifying the value types\n        typeConversionMap(dict): Map from type to corresponding conversion function. If None default conversions for string values are used.\n    \"\"\"\n    if typeConversionMap is None:\n\n        def toDate(value):\n            if isinstance(value, str):\n                return dateparser.parse(value).date()\n            elif isinstance(value, datetime):\n                return value.date()\n            elif isinstance(value, date):\n                return value\n            else:\n                print(f\"{value} could not be converted to date\")\n                return value\n\n        typeConversionMap = {\n            str: lambda value: str(value),\n            int: lambda value: int(value),\n            float: lambda value: float(value),\n            date: lambda value: toDate(value),\n            datetime: lambda value: dateparser.parse(value),\n        }\n    # build sample types map\n    sampleTypes = {}\n    for sample in samples:\n        if isinstance(sample, dict):\n            for key, value in sample.items():\n                valueType = type(value)\n                if key not in sampleTypes:\n                    sampleTypes[key] = valueType\n                elif sampleTypes[key] != valueType:\n                    print(\n                        f\"Sample has inconsistent types for {key} the types {sampleTypes[key]} and {valueType} are defined\"\n                    )\n                else:\n                    pass\n    # fix types of lod\n    for d in lod:\n        if isinstance(d, dict):\n            for key, value in d.items():\n                if (\n                    value is not None\n                    and key in sampleTypes\n                    and sampleTypes[key] in typeConversionMap\n                ):\n                    if type(value) != sampleTypes[key]:\n                        d[key] = typeConversionMap[sampleTypes[key]](value)\n        else:\n            print(\"List of dicts contains a non dict item\")\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.SpreadSheet.getTable","title":"<code>getTable(name)</code>","text":"<p>returns the data corresponding to the given table name Args:     name: name of the table</p> <p>Returns:</p> Type Description <p>LoD</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>def getTable(self, name: str):\n    \"\"\"\n    returns the data corresponding to the given table name\n    Args:\n        name: name of the table\n\n    Returns:\n        LoD\n    \"\"\"\n    if name in self.tables:\n        return self.tables[name]\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.SpreadSheet.hasTable","title":"<code>hasTable(name)</code>","text":"<p>Checks if table under given name exists</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>name of the Table</p> required Retruns <p>True if table exists otherwise False</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>def hasTable(self, name: str):\n    \"\"\"\n    Checks if table under given name exists\n\n    Args:\n        name(str): name of the Table\n\n    Retruns:\n        True if table exists otherwise False\n    \"\"\"\n    return name in self.tables\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.SpreadSheet.load","title":"<code>load(document)</code>  <code>classmethod</code>","text":"<p>Tries to load the given document as SpreadSheet Args:     document: onlinespreadsheet document to load</p> <p>Returns:</p> Type Description <p>SpreadSheet</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>@classmethod\ndef load(cls, document):\n    \"\"\"\n    Tries to load the given document as SpreadSheet\n    Args:\n        document: onlinespreadsheet document to load\n\n    Returns:\n        SpreadSheet\n    \"\"\"\n    documentSpreadSheetType = None\n    documentName = \"\"\n    spreadsheet = None\n    # TODO - use SpreadSheeeType enum instead\n    spreadSheetTypes = [OdsDocument, ExcelDocument, CSVSpreadSheet]\n    # TODO Get rid of Werkzeug dependency ...\n    # if isinstance(document, FileStorage):\n    #    document.stream.seek(0)\n    #    for spreadSheetType in spreadSheetTypes:\n    #        if document.filename.endswith(spreadSheetType.FILE_TYPE):\n    #            documentName=document.filename[:-len(spreadSheetType.FILE_TYPE)]\n    #            documentSpreadSheetType=spreadSheetType\n    #            break\n    if (\n        isinstance(document, io.BytesIO)\n        or isinstance(document, io.StringIO)\n        or isinstance(document, io.TextIOWrapper)\n    ):\n        document.seek(0)\n        for spreadSheetType in spreadSheetTypes:\n            if document.name.endswith(spreadSheetType.FILE_TYPE):\n                documentName = document.name[: -len(spreadSheetType.FILE_TYPE)]\n                documentSpreadSheetType = spreadSheetType\n                break\n    elif isinstance(document, str):\n        try:\n            buffer = None\n            with open(document, \"rb\") as f:\n                buffer = io.BytesIO(f.read())\n                buffer.name = document\n            return cls.load(buffer)\n        except Exception as e:\n            print(e)\n            raise e\n    else:\n        print(\"Unable to load SpreadSheet\")\n        return None\n    if documentSpreadSheetType:\n        spreadsheet = documentSpreadSheetType(name=documentName)\n        spreadsheet.loadFromFile(document)\n    return spreadsheet\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.SpreadSheet.loadFromFile","title":"<code>loadFromFile(file, samples=None)</code>","text":"<p>Load SpreadSheet from given file or file object</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>def loadFromFile(self, file, samples: dict = None):\n    \"\"\"\n    Load SpreadSheet from given file or file object\n    \"\"\"\n    tables = self._loadFromFile(file)\n    if tables:\n        for name, table in tables.items():\n            if samples:\n                if name in samples:\n                    self.fixLodTypes(table, samples[name])\n            self.tables[name] = table\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.SpreadSheet.saveToFile","title":"<code>saveToFile(fileName=None, dir_name=None)</code>","text":"<p>saves SpreadSheet to file</p> <p>Parameters:</p> Name Type Description Default <code>fileName(str)</code> <p>name of the file if None SpreadSheet name is used</p> required <code>dir_name(str)</code> <p>name of directory to store the file</p> required <p>Returns:</p> Type Description <p>Nothing</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>def saveToFile(self, fileName: str = None, dir_name: str = None):\n    \"\"\"\n    saves SpreadSheet to file\n\n    Args:\n        fileName(str): name of the file if None SpreadSheet name is used\n        dir_name(str): name of directory to store the file\n\n    Returns:\n        Nothing\n    \"\"\"\n    if fileName is None:\n        fileName = self.filename\n    if dir_name is not None:\n        fileName = os.path.join(dir_name, fileName)\n    documentBuffer = self.toBytesIO()\n    with open(fileName, \"wb\") as f:\n        documentBuffer.seek(0)\n        f.write(documentBuffer.read())\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.SpreadSheet.toBytesIO","title":"<code>toBytesIO()</code>","text":"<p>Converts the document into an BytesIO stream</p> <p>Returns:</p> Type Description <code>BytesIO</code> <p>BytesIO Stream of the document</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>def toBytesIO(self) -&gt; BytesIO:\n    \"\"\"\n    Converts the document into an BytesIO stream\n\n    Returns:\n        BytesIO Stream of the document\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"#spreadsheet.spreadsheet.SpreadSheetType","title":"<code>SpreadSheetType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Entities of openresearch. Used to specify for a fixer the domain of operation.</p> Source code in <code>spreadsheet/spreadsheet.py</code> <pre><code>class SpreadSheetType(Enum):\n    \"\"\"\n    Entities of openresearch.\n    Used to specify for a fixer the domain of operation.\n    \"\"\"\n\n    CSV = auto()\n    EXCEL = auto()\n    ODS = auto()\n    JSON = auto()\n\n    def getProperty(self, propertyName):\n        value = Format.formatMap[self.name][propertyName]\n        return value\n\n    def getPostfix(self):\n        return self.getProperty(\"postfix\")\n\n    def getName(self):\n        return self.getProperty(\"name\")\n\n    def getMimeType(self):\n        return self.getProperty(\"mimetype\")\n\n    def getTitle(self):\n        return self.getProperty(\"title\")\n\n    @classmethod\n    def asSelectFieldChoices(cls):\n        choices = []\n        for i, choice in enumerate(cls):\n            choices.append((choice.name, choice.getTitle()))\n        return choices\n</code></pre>"},{"location":"#spreadsheet.tableediting","title":"<code>tableediting</code>","text":"<p>Created on 2021-12-08</p> <p>@author: wf</p>"},{"location":"#spreadsheet.tableediting.TableEditing","title":"<code>TableEditing</code>","text":"<p>               Bases: <code>object</code></p> <p>table Editing</p> <p>enhancement onlinespreadsheet editing call validation</p> Source code in <code>spreadsheet/tableediting.py</code> <pre><code>class TableEditing(object):\n    \"\"\"\n    table Editing\n\n    enhancement\n    onlinespreadsheet editing call\n    validation\n    \"\"\"\n\n    def __init__(self, lods: dict = None):\n        \"\"\"\n        Constructor\n\n        Args:\n            lods(dict): a dict of list of dicts that represents the content of a Spreadsheet\n        \"\"\"\n        if lods is None:\n            self.lods = {}\n        else:\n            self.lods = lods\n        self.enhanceCallbacks = []  # functions to call for enhancing\n\n    def toSpreadSheet(self, spreadSheetType: SpreadSheetType, name: str) -&gt; SpreadSheet:\n        \"\"\"\n        convert me to the given spreadSheetType\n\n        Args:\n            spreadSheetType(SpreadSheetType): the type of onlinespreadsheet to create\n            name(str): the name of the onlinespreadsheet\n        \"\"\"\n        spreadSheet = SpreadSheet.create(spreadSheetType, name=name)\n        spreadSheet.tables = self.lods\n        return spreadSheet\n\n    def fromSpreadSheet(self, spreadSheet: SpreadSheet):\n        pass\n\n    def addLoD(self, name, lod):\n        \"\"\"\n        add the given list of dicts with the given name to my lods\n\n        Args:\n            name(str): the name\n            lod(list): the list of dicts to add\n        \"\"\"\n        self.lods[name] = lod\n\n    def addEnhancer(self, callback):\n        \"\"\"\n        add the given enhancer callback to my callbacks\n\n        Args:\n            callback(func): the callback function to add\n        \"\"\"\n        self.enhanceCallbacks.append(callback)\n\n    def enhance(self):\n        \"\"\"\n        enhance/enrich my list of dicts with the set callbacks\n        \"\"\"\n        for callback in self.enhanceCallbacks:\n            callback(self)\n</code></pre>"},{"location":"#spreadsheet.tableediting.TableEditing.__init__","title":"<code>__init__(lods=None)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>lods(dict)</code> <p>a dict of list of dicts that represents the content of a Spreadsheet</p> required Source code in <code>spreadsheet/tableediting.py</code> <pre><code>def __init__(self, lods: dict = None):\n    \"\"\"\n    Constructor\n\n    Args:\n        lods(dict): a dict of list of dicts that represents the content of a Spreadsheet\n    \"\"\"\n    if lods is None:\n        self.lods = {}\n    else:\n        self.lods = lods\n    self.enhanceCallbacks = []  # functions to call for enhancing\n</code></pre>"},{"location":"#spreadsheet.tableediting.TableEditing.addEnhancer","title":"<code>addEnhancer(callback)</code>","text":"<p>add the given enhancer callback to my callbacks</p> <p>Parameters:</p> Name Type Description Default <code>callback(func)</code> <p>the callback function to add</p> required Source code in <code>spreadsheet/tableediting.py</code> <pre><code>def addEnhancer(self, callback):\n    \"\"\"\n    add the given enhancer callback to my callbacks\n\n    Args:\n        callback(func): the callback function to add\n    \"\"\"\n    self.enhanceCallbacks.append(callback)\n</code></pre>"},{"location":"#spreadsheet.tableediting.TableEditing.addLoD","title":"<code>addLoD(name, lod)</code>","text":"<p>add the given list of dicts with the given name to my lods</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>the name</p> required <code>lod(list)</code> <p>the list of dicts to add</p> required Source code in <code>spreadsheet/tableediting.py</code> <pre><code>def addLoD(self, name, lod):\n    \"\"\"\n    add the given list of dicts with the given name to my lods\n\n    Args:\n        name(str): the name\n        lod(list): the list of dicts to add\n    \"\"\"\n    self.lods[name] = lod\n</code></pre>"},{"location":"#spreadsheet.tableediting.TableEditing.enhance","title":"<code>enhance()</code>","text":"<p>enhance/enrich my list of dicts with the set callbacks</p> Source code in <code>spreadsheet/tableediting.py</code> <pre><code>def enhance(self):\n    \"\"\"\n    enhance/enrich my list of dicts with the set callbacks\n    \"\"\"\n    for callback in self.enhanceCallbacks:\n        callback(self)\n</code></pre>"},{"location":"#spreadsheet.tableediting.TableEditing.toSpreadSheet","title":"<code>toSpreadSheet(spreadSheetType, name)</code>","text":"<p>convert me to the given spreadSheetType</p> <p>Parameters:</p> Name Type Description Default <code>spreadSheetType(SpreadSheetType)</code> <p>the type of onlinespreadsheet to create</p> required <code>name(str)</code> <p>the name of the onlinespreadsheet</p> required Source code in <code>spreadsheet/tableediting.py</code> <pre><code>def toSpreadSheet(self, spreadSheetType: SpreadSheetType, name: str) -&gt; SpreadSheet:\n    \"\"\"\n    convert me to the given spreadSheetType\n\n    Args:\n        spreadSheetType(SpreadSheetType): the type of onlinespreadsheet to create\n        name(str): the name of the onlinespreadsheet\n    \"\"\"\n    spreadSheet = SpreadSheet.create(spreadSheetType, name=name)\n    spreadSheet.tables = self.lods\n    return spreadSheet\n</code></pre>"},{"location":"#spreadsheet.version","title":"<code>version</code>","text":"<p>Created on 2022-04-21</p> <p>@author: wf</p>"},{"location":"#spreadsheet.version.Version","title":"<code>Version</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pyGenericSpreadSheet</p> Source code in <code>spreadsheet/version.py</code> <pre><code>class Version(object):\n    \"\"\"\n    Version handling for pyGenericSpreadSheet\n    \"\"\"\n\n    version = spreadsheet.__version__\n    date = \"2022-04-21\"\n    updated = \"2024-05-19\"\n    name = \"pyGenericSpreadSheet\"\n    description = \"python API providing generic Access to specific Spreadsheet backends\"\n</code></pre>"}]}